package mycore

import chisel3._
import chisel3.util._
import chisel3.experimental._
import chisel3.experimental.BundleLiterals._
import chisel3.util.experimental.BoringUtils

import constants.RV64I._
import constants.RV64M._
import constants.Constraints._

class amoAccesser_IO extends Bundle
{
    val dmem = new sram_like_io{
        val isWrite = Output(Bool())
        val mmu_en = Output(Bool())
    }
    val en = Input(Bool())
    val rs1 = Input(UInt(64.W))
    val rs2 = Input(UInt(64.W))
    val is_word = Input(Bool())
    val op_code = Input(UInt(4.W))
    val pipeline_stall = Input(Bool())

    val amo_valid = Output(Bool())
    val amo_exception = new Bundle{
        val valid = Output(Bool())
        val missalign = Output(Bool())
        val page_fault = Output(Bool())
    }
    val amo_result = Output(UInt(64.W))

}

class amoAccesser extends Module
{
    val io = IO(new amoAccesser_IO)

    io := DontCare

    val s_idle :: s_access :: s_exe :: s_write_back :: s_fail :: s_success :: Nil = Enum(6)

    val amo_stage = RegInit(s_idle)
    val alu = Module(new amo_alu)
    alu.io := DontCare

    //signals from cpath when amoAccesser does mem request 
    //so that we can acknowledge whether there is a page fault happenning 
    val pf_valid = WireInit(false.B)
    val loadPageFault = WireInit(false.B)
    val storePageFault = WireInit(false.B)

    BoringUtils.addSink(pf_valid,"cpath_pf_valid")
    BoringUtils.addSink(loadPageFault,"cpath_loadPageFault")
    BoringUtils.addSink(storePageFault,"cpath_storePageFault")

    //generated by missalign 
    val valid_access_req  = WireInit(false.B)

    val data_load = RegInit(0.U(64.W))
    val data_store = RegInit(0.U(64.W))
    val data_out = RegInit(0.U(64.W))

    valid_access_req := Mux(io.is_word,io.rs1(1,0) === 0.U,io.rs1(2,0) === 0.U)

    switch(amo_stage)
    {
        is(s_idle)
        {
            io.dmem.memen := false.B
            io.amo_valid  := false.B
            alu.io.en := false.B
            when(io.en)
            {
                when(valid_access_req)
                {
                    amo_stage := s_access
                }.otherwise
                {
                    amo_stage := s_fail
                }
            }
        }
        is(s_access)
        {
            //now it's a valid request and we have to access d$ to get the first operator
            io.dmem.memen   := true.B
            io.dmem.mask    := mask_x
            io.dmem.op      := Mux(io.is_word,op_wu,op_d)
            io.dmem.wdata   := DontCare
            io.dmem.mmu_en  := true.B
            io.dmem.isWrite := false.B
            io.dmem.wen     := false.B
            io.dmem.addr    := io.rs1

            io.amo_valid  := false.B
            alu.io.en := false.B
            when(io.dmem.data_valid)
            {
                //check if there is a page fault 
                when(pf_valid)
                {
                    //page fault happens , kill the whole process 
                    amo_stage := s_fail
                }.otherwise
                {
                    data_load := io.dmem.rdata
                    amo_stage := s_exe
                }
            }.otherwise
            {
                amo_stage := s_access
            }

        }
        is(s_exe)
        {
            io.amo_valid := false.B
            io.dmem.memen := false.B
            //prepare operator for alu
            alu.io.op1 := data_load
            alu.io.op2 := io.rs2
            alu.io.is_word := io.is_word
            alu.io.op_code := io.op_code
            alu.io.en := true.B

            data_store := alu.io.out_mem
            data_out := alu.io.out_rd
            amo_stage := s_write_back

        }
        is(s_write_back)
        {
            //now we get the alu result from exe stage 
            //we have to write it back to mem
            io.dmem.memen   := true.B
            io.dmem.mask    := Mux(io.is_word,mask_w,mask_dw)
            io.dmem.op      := op_x
            io.dmem.wdata   := data_store
            io.dmem.mmu_en  := true.B
            io.dmem.isWrite := true.B
            io.dmem.wen     := true.B
            io.dmem.addr    := io.rs1

            io.amo_valid  := false.B
            alu.io.en := false.B
            when(io.dmem.data_valid)
            {
                //check if there is a page fault 
                when(pf_valid)
                {
                    //page fault happens , kill the whole process 
                    amo_stage := s_fail
                }.otherwise
                {
                    amo_stage := s_success
                }
            }
        }
        is(s_fail)
        {
            io.dmem.memen := false.B
            alu.io.en := false.B
            
            io.amo_valid  := true.B
            io.amo_exception.valid := true.B
            when(pf_valid)
            {
                io.amo_exception.page_fault := true.B
            }.elsewhen(!valid_access_req)
            {
                io.amo_exception.missalign := true.B
            }
            io.amo_result := DontCare
            when(!io.pipeline_stall)
            {
                amo_stage := s_idle
            }.otherwise
            {
                amo_stage := s_fail
            }
                     
        }
        is(s_success)
        {
            io.dmem.memen := false.B
            alu.io.en := false.B

            io.amo_valid  := true.B
            io.amo_exception.valid := false.B
            io.amo_result := data_out
            when(!io.pipeline_stall)
            {
                amo_stage := s_idle
            }.otherwise
            {
                amo_stage := s_success
            }
        }
    }
}
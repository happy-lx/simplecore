### PTW的虚拟地址转化为物理地址算法

![2020-11-15 13-11-47 的屏幕截图](/home/lx/图片/2020-11-15 13-11-47 的屏幕截图.png)

+ sv39是三级页表结构，首先需要从`sapt`csr寄存器中得到root页表的基地址，然后根据vpn[2]来选择pte，首先看看是不是指向下一级页表的pte，如果R，W，X都是0则是指向下一级页表的pte，否则就是一个leaf 的pte。
+ 如果是leaf pte则检查一下当前的操作是不是可以接受，如果可以被接受，则看一下当前是第几个level，对应的只把0到这个level的ppn设置为vpn,这个level到2的ppn设置为pte的ppn，如果0到这个level的ppn不是0则发生page fault，offset直接设置即可
+ 如果是指向下一级的pte，则重新拿出ppn作为基地址，根据vpn[1]来进行选择pte，如果是最后一级则是根据vpn[0]来进行选择pte

### TLB

+ TLB的一个entry可以是一个pte的复制品，需要额外给上vpn[0],vpn[1],vpn[2]以供判断va是不是最终对应这个entry，如果是的话直接进行转换
+ 可以再加一个valid位，表示当前这个entry是不是有效的，初始全部都是无效的，TLB miss之后去PTW进行地址转化，将这个对应关系写到TLB中并设置valid位为1,之后的转化就可以直接查表进行，如果全部entry都是valid了，且发生了TLB miss则需要替换掉一个entry，可以直接采用随机替换策略，搞一个寄存器放index，随着时钟周期进行自加，加到最大后变0,每次如果要进行替换就使用这个寄存器的index进行替换即可。TLB也采取写回的方式，如果有store操作，会把TLB的某一个pte复制品的D位置1,就出现TLB和ram中的page table内容不一致的情况，所以可以额外增加一位M(modify)，表示pte的复制品是否被更改过，如果被更改过在选择替换这个pte的时候，需要把这个pte的内容写回到ram中保证一致性。



### 关于TLB与PTW的结合

+ 请求都是发送给TLB的
+ TLB首先需要判断是不是开启了需要进行地址转换的开关
  + 如果打开，则先需要判断是不是虚地址符合规范
  + 如果符合规范，先在TLB内部找是不是有TLB hit，如果hit的话直接进行地址转换
  + 如果miss则启动PTW，并在TLB中选出一个位置来放从PTW中取到的PTE
  + 在PTW工作的过程中，可能会有很多情况导致page fault，这样可以直接通知TLB有page fault，然后转换停止
  + PTW成功得到最后的PTE的时候，不会对里面的内容进行修改，而是直接给TLB，让TLB进行修改(在TLB的tlb_find_tlb阶段)
  + 在TLB中的某一项需要进行替换出去的时候，如果发生了修改就需要给ram中的page table进行写入
    + 所以PTW不会直接操作PTE，只有在TLB替换的时候才会把修改过后的PTE写入到page table中
    + **一致性的问题如何解决？**



### 11.23 修改

+ 对一致性的一些想法
  + 首先，所有的访存请求首先需要通过TLB，一开始一定是TLB缺失的，所以一定会启动PTW去从内存中读一个PTE过来，读来之后放到TLB中，然后TLB进行访问操作，这个时候如果是读，则要改变A bit ，如果是写，则要改变A D bit，这个时候必须要把对这两位的更改与内存中的PTE同步，即把这个表项再次写入到内存中
  + 如果A，D bit不需要发生改变，即此时TLB和内存中的PTE是一致的的时候，TLB命中就不需要访问内存，否则只要改变A D bit，一定要相应地更改内存中的PTE，也就是说当TLB中的一个entry需要替换出去的时候，是不需要重新写回内存的，因为TLB的entry一定是与内存中的PTE一致的。
  + 对于操作系统而言，只要改变了satp，或者对PTE又修改，就要使用指令刷新TLB，因为发生更改之后，TLB的映射关系就错误了
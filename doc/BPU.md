### BPU

+ 方向预测使用2位饱和分支预测主要用于beq bne bge等指令
+ 现在主要设计JAR，JARL两类指令的跳转目标地址预测

> 不用BTB可能会造成IF阶段成为关键路径，用BTB会提高时钟频率，但是缺失时多一个周期的损耗，并且预测失败时要刷掉IF，DEC阶段。由于流片时没有用BTB，以下也不使用BTB。

#### JAL

jal类型的指令把PC+4写到ra寄存器里面，基本上都是用作函数调用的直接跳转，所以在IF阶段取到指令之后直接把target地址算出来，也就是当前PC加上指令中的偏移量(不太可取，可能会降低时钟频率)，这样的预测不会发生失败，同时因为是函数调用，我们需要把返回地址写入到RAS中

+ 需要做出的修改
  + 首先IF阶段取出指令后判断是否是jal指令，是的话在dpath中直接算出地址。
  + 这个工作应该在bpu中进行，并且pc-select需要新增一个选项，pc_btb这个选项，在dpath中采用这个地址。
  + pc_btb加进来之后要注意pc-select的位宽是否发生改变，并且control-harzard的条件也要修改，对于pc_btb并不是control-harzard
  + 在cpath中检测到EXE阶段为jal类型的指令，不需要处理，因为已经在IF阶段处理过了



#### JALR

jalr类型的指令是使用寄存器中的内容作为PC，而这个寄存器的内容一般得等这条指令到达EXE阶段才可以确定(因为有数据相关)，所以有必要对它进行预测，这种间接跳转类型的指令有两种主要的使用情况，首先是对于立即数直接跳转寻址不够的情况使用寄存器间接寻址，第二种情况也是最普遍的情况就是RET指令，即jalr  $ra ，作为函数调用后的返回。那么IF阶段取到指令后发现是jalr $ra的话就从RAS中取出来栈顶的一项返回地址作为PC的值，然而这个PC的值并不一定就是正确的，所以这个target一定要跟随流水线流动到EXE阶段，然后EXE阶段算出来正确的值后如果发现没问题，就预测成功继续执行，如果预测失败，就杀死IF 和 DEC，PC重新设置为EXE阶段的正确的值

+ 需要做出的修改
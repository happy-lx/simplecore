### From 10/11

+ [x] 描述：`ecall`指令发生跳转时出现错误

  + 级别：严重

  + 原因：在流水线的`MEM`级时检测异常处理进行跳转，这时会置位`pipeline_kill`信号，由于这个信号的优先级高于`pipeline_stall`所以在`IF`阶段还没有取到指令时以及跳转了。
  + 解决办法：调整`pipeline_stall`的优先级大于`pipeline_kill`的优先级

### From 10/13

+ [x] 描述：串口读入数据的时候在多个周期内连续读入，导致错误
  + 级别：一般
  + 原因：在状态机的三个状态中，只有`burst`状态会真正进行读或者写，如果在这个状态中对串口读的控制信号置位，而其他状态没有对这个信号置低，就会导致在其他状态中这个信号一直为高，所以每一个周期都会进行读写而导致错误。
  + 解决办法：在其他几个状态机中让读的控制信号和写的控制信号都置低(代码写得比较乱，后面有时间得进行重构)

+ [x] 描述：`lw t1 , 0(t0) ; sw t1 , 0(t0)`的情况，及先`load`数据，再`store`数据，会导致`t1`不是`load`后最新的值
  + 级别：严重
  + 原因：我对`store`指令的编码没有注意，它是只有`rs1,rs2`的，之前为以为`t1`是在`rd`位置上面，及这种情况是`load use data hazard`
  + 解决办法：直接把`store`指令相关的`rs1_en,rs2_en `都设置为`true`即可

### From 10/14

+ [x] 描述：时钟中断无法处理
  + 级别：严重
  + 原因：过多使用`wire`，在流水线`stall`的时候检测到时钟中断，这时会更新各个相关的`csr`寄存器，并且设置流水线清除和跳转，但是这个时候由于`csr`中的`mstatus.mie`被设置为了`false`，并且这时流水线是停住的，没有即时跳转和清除，又加上使用的是`wire`，在下一个周期，由于`mstatus.mie == false`，所以中断检测信号就为`false`了，下一个周期相当于把上一个周期的时钟中断吃了
  + 解决办法：设置时钟中断的发生标志只在没有流水线停顿时置位即可
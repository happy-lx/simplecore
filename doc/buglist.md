### From 10/11

+ [x] 描述：`ecall`指令发生跳转时出现错误

  + 级别：严重

  + 原因：在流水线的`MEM`级时检测异常处理进行跳转，这时会置位`pipeline_kill`信号，由于这个信号的优先级高于`pipeline_stall`所以在`IF`阶段还没有取到指令时以及跳转了。
  + 解决办法：调整`pipeline_stall`的优先级大于`pipeline_kill`的优先级

### From 10/13

+ [x] 描述：串口读入数据的时候在多个周期内连续读入，导致错误
  + 级别：一般
  + 原因：在状态机的三个状态中，只有`burst`状态会真正进行读或者写，如果在这个状态中对串口读的控制信号置位，而其他状态没有对这个信号置低，就会导致在其他状态中这个信号一直为高，所以每一个周期都会进行读写而导致错误。
  + 解决办法：在其他几个状态机中让读的控制信号和写的控制信号都置低(代码写得比较乱，后面有时间得进行重构)

+ [x] 描述：`lw t1 , 0(t0) ; sw t1 , 0(t0)`的情况，及先`load`数据，再`store`数据，会导致`t1`不是`load`后最新的值
  + 级别：严重
  + 原因：我对`store`指令的编码没有注意，它是只有`rs1,rs2`的，之前为以为`t1`是在`rd`位置上面，及这种情况是`load use data hazard`
  + 解决办法：直接把`store`指令相关的`rs1_en,rs2_en `都设置为`true`即可

### From 10/14

+ [x] 描述：时钟中断无法处理
  + 级别：严重
  + 原因：过多使用`wire`，在流水线`stall`的时候检测到时钟中断，这时会更新各个相关的`csr`寄存器，并且设置流水线清除和跳转，但是这个时候由于`csr`中的`mstatus.mie`被设置为了`false`，并且这时流水线是停住的，没有即时跳转和清除，又加上使用的是`wire`，在下一个周期，由于`mstatus.mie == false`，所以中断检测信号就为`false`了，下一个周期相当于把上一个周期的时钟中断吃了
  + 解决办法：设置时钟中断的发生标志只在没有流水线停顿时置位即可

+ [x] 描述：`MIP`和`MIE`的寄存器格式错误
  + 级别：轻微
  + 原因：写的代码和指令手册上不符合
  + 解决办法：改正于手册一致即可

### From 10/15

+ [x] 描述：`Cat API`使用方法有问题
  + 级别：一般
  + 原因：猜测`Cat`这个`API`如果接受一个`Vec`,是反向连接的，导致高位都倒到低位去了，所以导致结果一直都是0
  + 解决办法：把`Cat`写全，或者加一个`reverse`
+ [x] 描述：`AM`编译的测试用例运行时不知为什么没有在串口输出东西
  + 级别：严重
  + 原因：只是从反汇编后的汇编代码得到读如内存的数据，除了代码还应该有相应的数据
  + 解决办法：从elf文件中提取读如到内存的数据
+ [x] 描述：同步异常无法正常响应
  + 级别：严重
  + 原因：控制通路中`pipeline_kill`优先级高于`pipeline_stall`所以当流水线停顿的时候`kill`信号会把这一个周期的异常信号直接杀死
  + 解决办法：调整控制通路的`stall`优先级高于`kill`

### From 10/18

+ [x] 描述：`srlw`指令执行出错
  + 级别：一般
  + 原因：没有注意这种指令只能取第二个操作数的后5位，我取了6位
  + 解决办法：只取后5位
+ [ ] 描述：时钟中断可能有点问题，只有当频率比较高的时候才可以正常启动RTT
  + 级别：严重
  + 原因：可能是时钟中断相关的内容有问题
  + 解决办法：
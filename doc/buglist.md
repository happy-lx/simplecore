### From 10/11

+ [x] 描述：`ecall`指令发生跳转时出现错误

  + 级别：严重

  + 原因：在流水线的`MEM`级时检测异常处理进行跳转，这时会置位`pipeline_kill`信号，由于这个信号的优先级高于`pipeline_stall`所以在`IF`阶段还没有取到指令时以及跳转了。
  + 解决办法：调整`pipeline_stall`的优先级大于`pipeline_kill`的优先级

### From 10/13

+ [x] 描述：串口读入数据的时候在多个周期内连续读入，导致错误
  + 级别：一般
  + 原因：在状态机的三个状态中，只有`burst`状态会真正进行读或者写，如果在这个状态中对串口读的控制信号置位，而其他状态没有对这个信号置低，就会导致在其他状态中这个信号一直为高，所以每一个周期都会进行读写而导致错误。
  + 解决办法：在其他几个状态机中让读的控制信号和写的控制信号都置低(代码写得比较乱，后面有时间得进行重构)

+ [x] 描述：`lw t1 , 0(t0) ; sw t1 , 0(t0)`的情况，及先`load`数据，再`store`数据，会导致`t1`不是`load`后最新的值
  + 级别：严重
  + 原因：我对`store`指令的编码没有注意，它是只有`rs1,rs2`的，之前为以为`t1`是在`rd`位置上面，及这种情况是`load use data hazard`
  + 解决办法：直接把`store`指令相关的`rs1_en,rs2_en `都设置为`true`即可

### From 10/14

+ [x] 描述：时钟中断无法处理
  + 级别：严重
  + 原因：过多使用`wire`，在流水线`stall`的时候检测到时钟中断，这时会更新各个相关的`csr`寄存器，并且设置流水线清除和跳转，但是这个时候由于`csr`中的`mstatus.mie`被设置为了`false`，并且这时流水线是停住的，没有即时跳转和清除，又加上使用的是`wire`，在下一个周期，由于`mstatus.mie == false`，所以中断检测信号就为`false`了，下一个周期相当于把上一个周期的时钟中断吃了
  + 解决办法：设置时钟中断的发生标志只在没有流水线停顿时置位即可

+ [x] 描述：`MIP`和`MIE`的寄存器格式错误
  + 级别：轻微
  + 原因：写的代码和指令手册上不符合
  + 解决办法：改正于手册一致即可

### From 10/15

+ [x] 描述：`Cat API`使用方法有问题
  + 级别：一般
  + 原因：猜测`Cat`这个`API`如果接受一个`Vec`,是反向连接的，导致高位都倒到低位去了，所以导致结果一直都是0
  + 解决办法：把`Cat`写全，或者加一个`reverse`
+ [x] 描述：`AM`编译的测试用例运行时不知为什么没有在串口输出东西
  + 级别：严重
  + 原因：只是从反汇编后的汇编代码得到读如内存的数据，除了代码还应该有相应的数据
  + 解决办法：从elf文件中提取读如到内存的数据
+ [x] 描述：同步异常无法正常响应
  + 级别：严重
  + 原因：控制通路中`pipeline_kill`优先级高于`pipeline_stall`所以当流水线停顿的时候`kill`信号会把这一个周期的异常信号直接杀死
  + 解决办法：调整控制通路的`stall`优先级高于`kill`

### From 10/18

+ [x] 描述：`srlw`指令执行出错
  + 级别：一般
  + 原因：没有注意这种指令只能取第二个操作数的后5位，我取了6位
  + 解决办法：只取后5位
+ [x] 描述：时钟中断可能有点问题，只有当频率比较高的时候才可以正常启动RTT
  + 级别：严重
  + 原因：`RT-Thread`的代码中处理时钟中断时，需要有一个关中断的操作，即就是把`mstatus`的`mie`清除，使用的是`csrrci`指令，本来是`t & ~ zimm`，但是我写成了`zimm & ~ t`导致本来是一个关中断的操作变成了一个开中断的操作，及在处理时钟中断的时候又重新跳到`trap_entry`了，变成了一个四循环
  + 解决办法：改成`t & ~ zimm`即可
+ [x] 描述：执行一些无关的指令导致csr寄存器的内容发生变化
  + 级别：严重
  + 原因：在csr寄存器里有一个信号来控制是否进行写操作，这个信号没有保证本条指令是csr相关的指令，所以当有其他一些无关指令的编码满足其写信号置为条件时，写信号置位从而写入一个无效的数据
  + 解决办法：加判断来保证此次是csr读写操作

### From 10/21

+ [x] 描述：时钟中断的时候，`mepc`的值发生错误
  + 级别：严重
  + 原因：因为流水线中可能会有由于`pipeline_kill`或者`control_hazard`发生时插入的`NOP`指令，而这些指令的`pc`我全部设置为了0，所以当在这个时候发生时钟中断的时候，`mepc`就会变成0，`mret`时pc就会变为0
  + 解决办法：等待`MEM`阶段的指令的`pc`不是0才可以发生时钟中断，因为`pc`只有在异常的情况下才会是0
+ [x] 描述：`mret`执行的时候有些问题
  + 级别：严重
  + 原因：因为流水线中有流水线的停顿，所以在`MEM`阶段的指令会停留比较多的时钟周期，如果是一条`mret`指令，则会多次进行`mstatus`等csr寄存器的写入，从而造成csr寄存器的内容不对
  + 解决办法：等待没有流水线停顿的时候才进行相应的操作

### From 10/23

+ [x] 描述：时钟中断的时候，指令重复执行，即中断前执行一次，中断后执行一次
  + 级别：严重
  + 原因：代码是这样写的，但是会导致像`addi sp,sp,-16`这种指令发生时钟中断时重复执行两次，导致实际的`sp`值不对
  + 解决办法：目前暂时用到一个比较取巧的方式，当时钟中断发生时，`MEM`阶段如果发送了异常，`mret`，则`mepc`的值等于`MEM`阶段的pc值，否则如果`EXE`阶段的pc只要不等于0就用他的pc，如果等于0就用`DEC`阶段的，同理一直到`IF`阶段，这样可以保证每次中断返回到的是一个正确的位置，但是这样解决感觉有点奇怪

### From 11/2

+ [x] 描述：分支预测器预测发生跳转时会丢失两条指令
  + 级别：严重
  + 原因：控制冒险信号是不为`pc_4`的时候发生，所以当我预测发生跳转时用`pc_bpu`的地址的时候发生控制冒险杀死两条指令，但是实际上并不应该杀死
  + 解决办法：控制冒险信号设置不为`pc_4`且不为`pc_bpu`的时候发生

### From 11/10

+ [x] 描述：cache加进入到流水线之后无法正常工作
  + 级别：严重
  + 原因：wire类型的变量`temp_index`,`temp_tag`,`temp_offset`,只在cache的`find_index`被设置，在其他的cache状态下为0，导致错误
  + 解决办法：`temp_index`,`temp_tag`,`temp_offset`在一开始就设置即可，即在cache的`idle`状态下设置好
+ [x] 描述：cache读出来的数据不正确
  + 级别：严重
  + 原因：`temp_offset`和`temp_index`写混了，换了个屏幕，眼睛不好使看不清
  + 解决办法：对应位置写正确的变量即可。

### From 11/12

+ [x] 描述：cache在某一种特定的指令下行为发生错误
  + 级别：严重
  + 原因：cache如果发生了写回内存的情况，会从状态`write_back`变为`write_allocate`，但是这个时候变量`read_time`的值被设置为了0，实际上应该是4，因为要从ram中读入4次64位的数据
  + 解决办法：在进入`write_allocate`的状态之前，设置好`read_time`的值为4

### From 11/14

+ [x] 描述：在访问`mtime`和`mtimecmp`的情况下发生锁死
  + 级别：严重
  + 原因：读和写分别有三个状态，在读的时候的最后一个状态下即`read_resp`，写的状态是`write_idle`，这个写的状态会把`data_valid`设置为`false`，导致`pipeline_stall`信号一直为`true`
  + 解决办法：为读和写分别设置一个valid信号，则`data_valid`为两者的或即可，这样就不会发生覆盖导致错误的情况

### From 11/26

+ [x] 描述：`rem t1 ,-10,3`这类指令计算结果错误
  + 级别：一般
  + 原因：之前对取余运算认识比较浅显，导致对于负数的这种特殊情况没有考虑周全
  + 解决办法：由于计算的时候都是当作无符号去做的，仅当第一个操作数为负数第二个操作数为正数或者两个操作数都是负数的时候把取余的结果变号，这样解决应该是没有太大的问题的

### From 11/30

+ [x] 描述：MMU接入到流水线之后，编译出来的verilog代码与预想不符合
  + 级别：一般
  + 原因：代码位置不对，导致对信号覆盖。为了接入到流水线，新添加的代码对信号进行了赋值，后面原来的代码对信号又赋予了DontCare，导致编译器对齐进行优化后得到的verilog代码与预想不符合
  + 解决办法：调整代码位置，将赋予DontCare信号的代码放到最上面

### From 12/12

+ [x] 描述：实现M/S/U模式之后，对RTT进行回归测试，其循环打印unhanded trap
  + 级别：一般
  + 原因：粗心把代码写错位置了，发生委托的代码应该操作的是S-mode的csr寄存器，写成了M-mode的寄存器，而不发生委托的代码一改操作M-mode的寄存器而写成了S-mode的寄存器，即互相写反了，所以当发生时钟中断时，异常原因写到了`scause`寄存器里面而没有写入`mcause`寄存器里，操作系统检测到`mcause`为0打印unhanded trap
  + 解决办法：调整代码位置，正确对应即可
+ [x] 描述：在实现cache与TLB的刷新之后执行`fence.i`指令卡死
  + 级别：严重
  + 原因：由于dcache在执行flush的时候，是不让IF阶段访存的，所以IF一直不访存流水线一直stall，然而dcache刷新操作完成之后回到了idle状态，这个时候由于流水线一直是stall的，所以MEM阶段仍然是`fence.i`指令，所以dcache又跑去执行flush操作了，陷入死循环
  + 解决办法：重新增加一个cache的状态，标明dcache已经完成flush操作，设置可以让IF访存，然后IF访存发生在icache刷新完后回到idle阶段检测到访存要求去访存，取到指令后，流水线准备就绪，stall信号降下来，让icache和dcache全部回到idle状态

### From 12/23

+ [x] 描述：发生page fault之后可能发生错误
  + 级别：不定
  + 原因：由于TLB发生page fault的标志信号只保留一个周期，MMU的page fault信号也只保留一个周期，这个信号传给cpath后也只保留一个周期，然而这个时候只是没有data_stall了，还可能存在instr_stall，所以流水线不能向前，然而这个周期过了之后，page fault的信号就消失了，而异常只在没有stall的时候才处理，所以当没有stall之后，这个异常信号就消失了而没有处理
  + 解决办法：给MMU增加三个状态，分别保留好page fault 信号等没有stall了之后才在下一个周期进入idle状态

### From 2/28

+ [x] 描述：启动linux内核时，开启分页后的第一条访问数据cache的指令会产生page fault
  + 级别：严重
  + 原因：我看了一本错误的riscv-privilege手册，版本太低了，地址转换算法有个地方写错了，当在页表不足三级的时候比如第一级页表应该去判断pte的ppn[0]和ppn[1]是不是0而不是去判断va的vpn[0]和vpn[1]
  + 解决办法：修改地址转换算法，去判断pte的ppn[0]和ppn[1]是不是0而不是去判断va的vpn[0]和vpn[1]

### From 2/28

+ [x] 描述：启动linux内核时，执行print的时候用ecall去调用sbi的打印功能时卡在0x80000004处
  + 级别：严重
  + 原因：在M模式下仍然在使用地址转换算法，所以0x80000004也被认为是一个虚拟地址进行了转换，然后得到的指令是jump到当前指令，因此一直死循环
  + 解决办法：修改地址转换算法的使用条件，只有在S和U模式下才使用，M模式下不使用